import { createCanvas, loadImage } from '@napi-rs/canvas';
import { getSpotifyAlbumInfo } from '../src/utils/spotifyUtils';

// Canvas configuration
const CANVAS_WIDTH = 1200;
const CANVAS_HEIGHT = 600;
const PADDING = 40;
const ALBUM_ART_SIZE = 200;

// Colors
const COLORS = {
  background: '#18181b',
  primary: '#10b981',
  text: '#ffffff',
  textSecondary: '#71717a',
  accent: '#059669'
};

export default async function handler(req, res) {
  const { artist, album } = req.query;
  
  if (!artist || !album) {
    return res.status(400).json({ 
      error: 'Missing required parameters',
      message: 'Both artist and album parameters are required'
    });
  }

  try {
    // Fetch album info from Spotify
    const albumInfo = await getSpotifyAlbumInfo(artist, album);
    if (!albumInfo) {
      throw new Error('Album not found');
    }

    // Create canvas
    const canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
    const ctx = canvas.getContext('2d');

    // Draw background
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Add gradient overlay
    const gradient = ctx.createLinearGradient(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    gradient.addColorStop(0, 'rgba(16, 185, 129, 0.1)');
    gradient.addColorStop(1, 'rgba(5, 150, 105, 0.05)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Load and draw album artwork
    if (albumInfo.imageUrl) {
      const albumArt = await loadImage(albumInfo.imageUrl);
      ctx.drawImage(albumArt, PADDING, PADDING, ALBUM_ART_SIZE, ALBUM_ART_SIZE);

      // Add reflection effect
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.translate(0, ALBUM_ART_SIZE + PADDING * 2);
      ctx.scale(1, -0.2);
      ctx.drawImage(albumArt, PADDING, PADDING, ALBUM_ART_SIZE, ALBUM_ART_SIZE);
      ctx.restore();
    }

    // Draw album info
    ctx.fillStyle = COLORS.text;
    ctx.font = 'bold 48px Arial';
    ctx.fillText(albumInfo.name, PADDING + ALBUM_ART_SIZE + PADDING, PADDING + 48);

    ctx.fillStyle = COLORS.textSecondary;
    ctx.font = '32px Arial';
    ctx.fillText(albumInfo.artists.join(', '), PADDING + ALBUM_ART_SIZE + PADDING, PADDING + 96);

    // Draw release date and tracks count
    ctx.fillStyle = COLORS.textSecondary;
    ctx.font = '24px Arial';
    const releaseYear = new Date(albumInfo.releaseDate).getFullYear();
    const trackInfo = `${releaseYear} â€¢ ${albumInfo.tracks.length} tracks`;
    ctx.fillText(trackInfo, PADDING + ALBUM_ART_SIZE + PADDING, PADDING + 140);

    // Draw track list preview
    const trackListStart = PADDING + 180;
    albumInfo.tracks.slice(0, 5).forEach((track, index) => {
      ctx.fillStyle = COLORS.textSecondary;
      ctx.font = '24px Arial';
      ctx.fillText(
        `${index + 1}. ${track.name} (${track.duration})`,
        PADDING + ALBUM_ART_SIZE + PADDING,
        trackListStart + (index * 40)
      );
    });

    // Add Spotify logo
    ctx.fillStyle = COLORS.primary;
    ctx.font = '24px Arial';
    ctx.fillText('Available on Spotify', CANVAS_WIDTH - 200, CANVAS_HEIGHT - PADDING);

    // Add watermark
    ctx.fillStyle = COLORS.textSecondary;
    ctx.font = '20px Arial';
    ctx.fillText('Generated by Vinylogue', PADDING, CANVAS_HEIGHT - PADDING);

    const buffer = await canvas.encode('png');
    
    // Set caching headers
    res.setHeader('Content-Type', 'image/png');
    res.setHeader('Cache-Control', 'public, max-age=86400'); // Cache for 24 hours
    res.setHeader('ETag', `"${artist}-${album}"`);
    
    res.send(buffer);
  } catch (error) {
    console.error('Error generating album card:', error);
    res.status(500).json({ 
      error: 'Failed to generate album card',
      message: error.message 
    });
  }
}