import { createCanvas, loadImage } from 'canvas';
import fetch from 'node-fetch';

const SPOTIFY_TOKEN_URL = 'https://accounts.spotify.com/api/token';
const SPOTIFY_API_URL = 'https://api.spotify.com/v1';

// Canvas configuration
const CANVAS_WIDTH = 1200;
const CANVAS_HEIGHT = 600;
const PADDING = 40;
const ALBUM_ART_SIZE = 200;

// Colors
const COLORS = {
  background: '#18181b',
  primary: '#10b981',
  text: '#ffffff',
  textSecondary: '#71717a',
  accent: '#059669'
};

async function getSpotifyToken() {
  const auth = Buffer.from(`${process.env.SPOTIFY_CLIENT_ID}:${process.env.SPOTIFY_CLIENT_SECRET}`).toString('base64');
  
  const response = await fetch(SPOTIFY_TOKEN_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Basic ${auth}`,
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: 'grant_type=client_credentials'
  });

  if (!response.ok) {
    throw new Error('Failed to get Spotify token');
  }

  const data = await response.json();
  return data.access_token;
}

async function getSpotifyAlbumInfo(artist, album) {
  const token = await getSpotifyToken();
  const query = `${album} artist:${artist}`;
  
  const searchResponse = await fetch(
    `${SPOTIFY_API_URL}/search?q=${encodeURIComponent(query)}&type=album&limit=1`,
    {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    }
  );

  if (!searchResponse.ok) {
    throw new Error('Failed to search album');
  }

  const searchData = await searchResponse.json();
  const albumId = searchData.albums?.items[0]?.id;
  
  if (!albumId) {
    throw new Error('Album not found');
  }

  const albumResponse = await fetch(
    `${SPOTIFY_API_URL}/albums/${albumId}`,
    {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    }
  );

  if (!albumResponse.ok) {
    throw new Error('Failed to get album details');
  }

  const albumData = await albumResponse.json();
  return {
    name: albumData.name,
    artists: albumData.artists.map(artist => artist.name),
    releaseDate: albumData.release_date,
    imageUrl: albumData.images[0]?.url,
    tracks: albumData.tracks.items.map(track => ({
      name: track.name,
      duration: msToMinutesAndSeconds(track.duration_ms)
    }))
  };
}

function msToMinutesAndSeconds(ms) {
  const minutes = Math.floor(ms / 60000);
  const seconds = Math.floor((ms % 60000) / 1000);
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

export async function generateAlbumCard(artist, album) {
  try {
    const albumInfo = await getSpotifyAlbumInfo(artist, album);
    
    const canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
    const ctx = canvas.getContext('2d');

    // Draw background
    ctx.fillStyle = COLORS.background;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Add gradient overlay
    const gradient = ctx.createLinearGradient(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    gradient.addColorStop(0, 'rgba(16, 185, 129, 0.1)');
    gradient.addColorStop(1, 'rgba(5, 150, 105, 0.05)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Load and draw album artwork
    if (albumInfo.imageUrl) {
      const albumArt = await loadImage(albumInfo.imageUrl);
      ctx.drawImage(albumArt, PADDING, PADDING, ALBUM_ART_SIZE, ALBUM_ART_SIZE);

      // Add reflection effect
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.translate(0, ALBUM_ART_SIZE + PADDING * 2);
      ctx.scale(1, -0.2);
      ctx.drawImage(albumArt, PADDING, PADDING, ALBUM_ART_SIZE, ALBUM_ART_SIZE);
      ctx.restore();
    }

    // Draw album info
    ctx.fillStyle = COLORS.text;
    ctx.font = 'bold 48px Arial';
    ctx.fillText(albumInfo.name, PADDING + ALBUM_ART_SIZE + PADDING, PADDING + 48);

    ctx.fillStyle = COLORS.textSecondary;
    ctx.font = '32px Arial';
    ctx.fillText(albumInfo.artists.join(', '), PADDING + ALBUM_ART_SIZE + PADDING, PADDING + 96);

    // Draw release date and tracks count
    ctx.fillStyle = COLORS.textSecondary;
    ctx.font = '24px Arial';
    const releaseYear = new Date(albumInfo.releaseDate).getFullYear();
    const trackInfo = `${releaseYear} â€¢ ${albumInfo.tracks.length} tracks`;
    ctx.fillText(trackInfo, PADDING + ALBUM_ART_SIZE + PADDING, PADDING + 140);

    // Draw track list preview
    const trackListStart = PADDING + 180;
    albumInfo.tracks.slice(0, 5).forEach((track, index) => {
      ctx.fillStyle = COLORS.textSecondary;
      ctx.font = '24px Arial';
      ctx.fillText(
        `${index + 1}. ${track.name} (${track.duration})`,
        PADDING + ALBUM_ART_SIZE + PADDING,
        trackListStart + (index * 40)
      );
    });

    // Add watermark
    ctx.fillStyle = COLORS.textSecondary;
    ctx.font = '20px Arial';
    ctx.fillText('Generated by Vinylogue', PADDING, CANVAS_HEIGHT - PADDING);

    return canvas.toBuffer('image/png');
  } catch (error) {
    console.error('Error generating album card:', error);
    throw error;
  }
}